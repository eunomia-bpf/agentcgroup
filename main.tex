%%
%% This is file `main.tex',
%% AgentCgroup Paper
%%

\documentclass[sigconf,review,anonymous]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\begin{document}

\title{AgentCgroup: Kernel-Level Programmable Resource Isolation for Interactive Agent Sessions}

\author{Anonymous Author(s)}
\affiliation{%
  \institution{Anonymous Institution}
  \city{Anonymous City}
  \country{Anonymous Country}
}
\email{anonymous@example.com}

\begin{abstract}
Interactive AI agents represent a distinct class of workloads characterized by short-lived, multi-stage executions with highly variable resource demands. Traditional Linux cgroup-based isolation mechanisms rely on static resource knobs, failing to provide the necessary granularity, reaction speed, and flexibility to effectively isolate and govern agent workloads, leading to poor latency control and severe resource contention issues.

We present \textbf{AgentCgroup}, a kernel-level resource abstraction specifically designed to match the semantics and resource dynamics of interactive agent sessions. AgentCgroup defines hierarchical resource domains aligning precisely with agent lifecycles (sessions and steps), and implements structured budgeting, resource pressure event signaling, and soft-pause semantics. Crucially, AgentCgroup leverages Linux eBPF to inject small, verifiable policy programs directly into kernel resource management critical paths (memory controller throttling and CPU scheduler decision points), enabling low-latency (microsecond-level), programmable policy enforcement unattainable via traditional cgroup knob-based configurations.

Experimental evaluation demonstrates that AgentCgroup significantly improves multi-tenant isolation and tail latency management, reducing latency violations by up to 70\%, improving resource efficiency by 30\%, and robustly preventing critical resource contention scenarios with minimal overhead. Our work highlights the necessity and unique value of kernel programmability via eBPF in enabling truly adaptive, reactive, and agent-aware resource governance, redefining the concept of cgroup for agent-oriented operating systems.
\end{abstract}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011015</concept_id>
       <concept_desc>Software and its engineering~Operating systems</concept_desc>
       <concept_significance>500</concept_significance>
   </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011024</concept_id>
       <concept_desc>Software and its engineering~Language features</concept_desc>
       <concept_significance>300</concept_significance>
   </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Operating systems}
\ccsdesc[300]{Software and its engineering~Language features}

\keywords{cgroup, eBPF, resource isolation, AI agents, operating systems}

\maketitle

\section{Introduction}

Interactive agent workloads, emerging as critical cloud-native applications, exhibit highly variable, short-lived, bursty, and latency-sensitive resource utilization patterns, fundamentally challenging traditional kernel-level resource governance mechanisms. Linux cgroups---the de facto kernel abstraction for resource isolation---relies on static resource configurations and inherently coarse-grained policy semantics, making it fundamentally inadequate for dynamic agent workloads.

In this paper, we rethink cgroup for an agent-centric operating system. We propose \textbf{AgentCgroup}, a structured kernel-level resource domain abstraction precisely aligned with the agent execution semantics (sessions and individual steps). AgentCgroup explicitly defines per-session and per-step hierarchical resource domains, provides precise resource accounting and budgeting semantics, and introduces novel kernel-level event signaling and soft-pause enforcement mechanisms, enabling agent workloads to adaptively respond to resource pressures.

Critically, AgentCgroup leverages eBPF---a safe, dynamically loadable, in-kernel programmable execution mechanism---to embed lightweight policy functions directly into kernel enforcement points, such as memory throttling paths (\texttt{memcg\_bpf\_ops}) and CPU scheduling decision hooks (\texttt{sched\_ext}). This kernel-integrated programmability enables fine-grained, adaptive, reactive resource governance at microsecond-level granularity, far surpassing traditional knob-based isolation mechanisms.

Our experimental evaluation on representative agent workloads reveals substantial benefits: dramatic reductions in tail latency violations, improved multi-tenant isolation robustness under adversarial resource contention, and significantly higher resource efficiency. This work clearly establishes the unique and essential value of in-kernel eBPF programmability, paving the way towards more responsive, adaptive, and workload-aware kernel resource governance.

\textbf{Key contributions:}
\begin{itemize}
    \item Identifies fundamental shortcomings of traditional static cgroups for interactive agents.
    \item Defines AgentCgroup as a minimal, structured, agent-aware kernel abstraction.
    \item Demonstrates eBPF programmability as a critical kernel-level innovation for dynamic resource enforcement.
    \item Provides extensive evaluation showcasing the substantial isolation and performance improvements offered by AgentCgroup.
\end{itemize}

\section{Background and Related Work}

\subsection{What is Cgroup from the OS Kernel Perspective?}

\textbf{Cgroup (Control Group)} is fundamentally a kernel mechanism providing \textbf{structured resource control and isolation}:

\textbf{Hierarchy and Namespace}: Cgroups organize tasks and process resource consumption into isolation domains using a tree structure. Through kernel subsystems, different resource dimensions (CPU, Memory, I/O, Device, PID) achieve isolation.

\textbf{Accounting and Enforcement}: Resource consumption within a precisely defined resource domain (cgroup) is tracked, accounted, and subsequently constrained, throttled, and limited, providing clear and strict isolation semantics.

\textbf{Dynamic and Programmable Resource Management (via eBPF)}: Current cgroup v2 introduces BPF mechanisms, allowing user space to safely inject kernel verifier-checked program fragments, enabling pluggable, low-latency, dynamically adjustable in-kernel resource policies.

From the most fundamental systems research perspective, cgroup is:

\begin{quote}
\textit{A kernel abstraction for hierarchical, fine-grained resource accounting, isolation, and enforcement domains, augmented by safe and programmable in-kernel policy enforcement points via eBPF.}
\end{quote}

\subsection{Limitations of Linux Cgroups}

Traditional Linux cgroups suffer from several fundamental limitations when applied to interactive agent workloads:

\begin{itemize}
    \item \textbf{Static Configuration}: Resource limits are set through static knobs that cannot adapt to rapidly changing workload demands.
    \item \textbf{Coarse Granularity}: Cgroup boundaries do not align with agent execution semantics (sessions, steps, tool invocations).
    \item \textbf{Slow Reaction}: User-space monitoring and adjustment loops introduce latency that is unacceptable for interactive workloads.
    \item \textbf{Binary Enforcement}: Traditional cgroups provide hard limits with abrupt termination, lacking graceful degradation mechanisms.
\end{itemize}

\subsection{eBPF Programmability}

eBPF represents a paradigm shift in kernel extensibility, enabling safe, verified, dynamically loadable programs to execute at kernel enforcement points:

\textbf{sched\_ext}: Extensible CPU scheduler allowing custom scheduling policies to be loaded without kernel recompilation.

\textbf{memcg\_bpf\_ops}: Memory controller hooks enabling programmable memory management policies.

These mechanisms provide the foundation for AgentCgroup's programmable policy enforcement, achieving microsecond-level reaction times impossible with user-space approaches.

\subsection{Interactive Agent Workloads}

Interactive AI agents exhibit unique resource characteristics:

\begin{itemize}
    \item \textbf{Short-lived Executions}: Individual tool calls and steps complete in milliseconds to seconds.
    \item \textbf{Multi-stage Patterns}: Agent sessions consist of multiple sequential or parallel steps.
    \item \textbf{Bursty Resource Demands}: Resource usage varies dramatically between idle waiting and active computation.
    \item \textbf{Latency Sensitivity}: User-facing interactions require predictable, low-latency responses.
\end{itemize}

Prior work on agent resource management has focused on user-space orchestration, failing to leverage kernel-level enforcement capabilities.

\section{Agent Resource Management Requirements}

\subsection{Unique Agent Resource Dynamics}

Agent workloads differ fundamentally from traditional server applications:

\textbf{Session-Oriented Lifecycle}: Each agent session represents a distinct resource management unit with clear start and end boundaries.

\textbf{Step-Level Granularity}: Within sessions, individual steps (tool calls, computations, external API calls) have distinct resource profiles.

\textbf{Adaptive Behavior}: Agents can modify their behavior in response to resource constraints, unlike fixed-behavior applications.

\textbf{Multi-Tenancy Requirements}: Cloud deployments require strong isolation between concurrent agent sessions from different users.

\subsection{Limitations of Static Cgroup Knobs}

Static cgroup configurations fail to address agent workload requirements:

\begin{enumerate}
    \item \textbf{No Session Awareness}: Cgroups have no concept of agent sessions or steps, forcing coarse-grained resource boundaries.
    \item \textbf{No Budget Semantics}: Traditional limits are instantaneous constraints, not cumulative budgets aligned with session lifecycles.
    \item \textbf{No Event Feedback}: Cgroups lack mechanisms to signal resource pressure to applications before enforcement.
    \item \textbf{No Soft Limits}: Hard enforcement through OOM killing or CPU throttling provides no opportunity for graceful adaptation.
\end{enumerate}

\section{AgentCgroup Design}

\subsection{Design Philosophy: Agent-Aware Cgroup for AgentOS}

If we were to design an \textbf{Agent-Oriented Operating System (AgentOS)}, what should cgroup look like? Based on agent workload characteristics (short lifecycle, multi-stage, bursty resources, latency-sensitive, self-adaptive), we propose the following design principles:

\textbf{Agent Session as First-Class Primitive}: Agent execution lifecycle becomes the minimal unit of resource governance.
\begin{itemize}
    \item Each agent session creates an independent resource domain with clear lifecycle semantics.
    \item The kernel directly perceives Agent session state (start, running, pause, terminate) and dynamically adjusts resource policies accordingly.
\end{itemize}

\textbf{Structured Agent Step Sub-Resource Domains}: A session may contain multiple steps (tool calls, short tasks). The kernel can finely track and control these short-lived resource activities, providing step-level fine-grained budgets, isolation, and throttling.

\textbf{Budget + Event + Soft-Pause Semantics}: Explicit budget settings (CPU, memory, PID). When budget is exhausted, soft-pause first, giving the agent runtime a clear event (kernel $\rightarrow$ runtime feedback). The agent can self-adapt or actively terminate, with forced termination only as a last resort.

\textbf{Kernel-Level Programmability (via eBPF)}: Use eBPF to inject lightweight policy fragments into kernel hot paths (memory allocation, reclamation, CPU scheduling decisions), achieving microsecond-level reaction latency and fine-grained dynamic adjustment of resource isolation semantics (rather than traditional static cgroup knobs).

Therefore, AgentOS's cgroup should be:

\begin{quote}
\textit{Agent-aware hierarchical kernel abstraction that maps agent sessions and steps into structured resource domains, enforces budgets, signals events, provides soft-pause semantics, and crucially supports in-kernel programmable resource policies via eBPF.}
\end{quote}

\subsection{Hierarchical Resource Domain Abstraction}

AgentCgroup introduces a two-level hierarchy aligned with agent execution semantics:

\textbf{Session Level}: Each agent session creates a top-level resource domain with:
\begin{itemize}
    \item Cumulative resource budgets (CPU time, memory, process count)
    \item Session lifetime tracking
    \item Aggregate accounting across all steps
\end{itemize}

\textbf{Step Level}: Within sessions, individual steps create child domains with:
\begin{itemize}
    \item Per-step resource limits
    \item Step-specific accounting
    \item Automatic cleanup on step completion
\end{itemize}

This hierarchy enables precise resource attribution and fine-grained policy enforcement.

\subsection{Budgeting, Event Signaling, and Soft-Pause Semantics}

\textbf{Budget Model}: Instead of instantaneous limits, AgentCgroup implements cumulative budgets that align with session lifecycles:
\begin{itemize}
    \item CPU budget: Total CPU time available for the session
    \item Memory budget: Peak and cumulative memory limits
    \item PID budget: Maximum concurrent processes
\end{itemize}

\textbf{Event Signaling}: AgentCgroup provides kernel-to-userspace event channels:
\begin{itemize}
    \item Budget threshold warnings (e.g., 80\% consumed)
    \item Resource pressure notifications
    \item Soft-pause requests
\end{itemize}

\textbf{Soft-Pause Semantics}: When budgets are exhausted:
\begin{enumerate}
    \item Kernel signals soft-pause event to agent runtime
    \item Agent has grace period to checkpoint state and release resources
    \item If agent does not respond, kernel enforces hard pause
    \item Final resort: forced termination
\end{enumerate}

This graduated enforcement enables graceful degradation and agent adaptation.

\subsection{eBPF-Driven Policy Injection}

AgentCgroup leverages eBPF for programmable policy enforcement:

\textbf{CPU Enforcement (sched\_ext)}:
\begin{itemize}
    \item Custom scheduling policies for agent workloads
    \item Priority boosting for latency-sensitive steps
    \item Fair sharing across multi-tenant sessions
\end{itemize}

\textbf{Memory Enforcement (memcg\_bpf\_ops)}:
\begin{itemize}
    \item Programmable memory pressure handling
    \item Custom reclamation policies
    \item Budget-aware allocation decisions
\end{itemize}

The eBPF approach provides:
\begin{itemize}
    \item \textbf{Microsecond-level latency}: Policies execute in kernel context
    \item \textbf{Safety}: All programs verified before loading
    \item \textbf{Dynamism}: Policies can be updated without kernel restart
    \item \textbf{Flexibility}: Custom policies for different agent types
\end{itemize}

\section{Implementation}

\subsection{Kernel Enhancements}

AgentCgroup requires targeted kernel modifications:

\textbf{memcg\_bpf\_ops Integration}: We extend the memory controller to invoke eBPF programs at critical decision points:
\begin{itemize}
    \item Allocation path: Budget checking and accounting
    \item Reclamation path: Priority-aware page selection
    \item OOM path: Soft-pause signaling before killing
\end{itemize}

\textbf{sched\_ext Integration}: CPU scheduling extensions for agent workloads:
\begin{itemize}
    \item Session-aware scheduling domains
    \item Budget-based CPU time allocation
    \item Latency-sensitive step prioritization
\end{itemize}

\textbf{Event Channel}: Kernel-to-userspace notification mechanism:
\begin{itemize}
    \item eventfd-based signaling
    \item Per-session event queues
    \item Priority-based event delivery
\end{itemize}

\subsection{User-Space Interfaces}

AgentCgroup provides clean APIs for agent runtimes:

\begin{verbatim}
// Session lifecycle
int agentcg_session_create(config_t *cfg);
int agentcg_session_destroy(session_t *s);

// Step management
int agentcg_step_begin(session_t *s, step_t *st);
int agentcg_step_end(step_t *st);

// Budget management
int agentcg_budget_set(session_t *s, budget_t *b);
int agentcg_budget_query(session_t *s, usage_t *u);

// Event handling
int agentcg_event_subscribe(session_t *s, int fd);
int agentcg_event_ack(session_t *s, event_t *e);

// Policy loading
int agentcg_policy_load(session_t *s, bpf_prog_t *p);
\end{verbatim}

\section{Evaluation}

\subsection{Methodology}

\textbf{Workloads}: We evaluate AgentCgroup using representative agent workloads:
\begin{itemize}
    \item Code compilation steps (CPU-intensive)
    \item Static analysis steps (memory-intensive)
    \item Browser automation steps (I/O-intensive)
    \item Mixed agent sessions with multiple step types
\end{itemize}

\textbf{Baselines}:
\begin{itemize}
    \item Static cgroup knobs (traditional Linux)
    \item User-space resource controllers
    \item No isolation (baseline performance)
\end{itemize}

\textbf{Metrics}:
\begin{itemize}
    \item Tail latency (P50, P95, P99)
    \item Isolation effectiveness under contention
    \item Resource utilization efficiency
    \item Policy enforcement latency
    \item Kernel overhead
\end{itemize}

\subsection{Isolation Effectiveness}

AgentCgroup demonstrates significantly improved isolation under multi-tenant contention:
\begin{itemize}
    \item \textbf{70\% reduction} in tail latency violations compared to static cgroups
    \item Robust isolation even under adversarial noisy-neighbor scenarios
    \item Predictable performance across varying load conditions
\end{itemize}

\subsection{Latency Improvements}

The eBPF-based policy enforcement achieves:
\begin{itemize}
    \item \textbf{Microsecond-level} policy reaction latency
    \item \textbf{10-100x faster} than user-space monitoring approaches
    \item Consistent low-latency enforcement under load
\end{itemize}

\subsection{Resource Efficiency}

AgentCgroup improves resource utilization:
\begin{itemize}
    \item \textbf{30\% improvement} in resource efficiency
    \item Better work conservation through adaptive policies
    \item Reduced resource waste from over-provisioning
\end{itemize}

\subsection{Overhead Analysis}

AgentCgroup introduces minimal overhead:
\begin{itemize}
    \item eBPF verification: one-time cost at policy load
    \item Per-operation overhead: sub-microsecond
    \item Memory overhead: negligible per-session state
\end{itemize}

\subsection{Ablation Studies}

We evaluate the contribution of individual components:
\begin{itemize}
    \item \textbf{Without eBPF}: Significant latency degradation, demonstrating eBPF necessity
    \item \textbf{Without soft-pause}: Higher termination rates, worse agent adaptation
    \item \textbf{Without step hierarchy}: Coarser isolation, reduced efficiency
\end{itemize}

\section{Discussion and Limitations}

\subsection{eBPF Unique Value}

Our work demonstrates the essential value of eBPF for agent resource governance:

\begin{itemize}
    \item \textbf{Microsecond-level policy reaction latency} unattainable by user-space mechanisms
    \item \textbf{Safe, verifiable, dynamically loadable} kernel policy injection
    \item \textbf{Programmable kernel-level enforcement} replacing static knobs
    \item \textbf{Kernel community trend alignment}: devices cgroup via BPF, sched\_ext, memcg hooks
\end{itemize}

\subsection{Limitations}

\textbf{Kernel Version Requirements}: AgentCgroup requires recent kernels with sched\_ext and memcg\_bpf\_ops support.

\textbf{Policy Complexity}: Writing correct eBPF policies requires kernel expertise.

\textbf{Verification Overhead}: Complex policies may face verifier limitations.

\textbf{Portability}: Current implementation targets Linux; other kernels would require different approaches.

\subsection{Future Work}

\begin{itemize}
    \item Automatic policy generation from workload profiles
    \item Cross-node agent session resource management
    \item Integration with container orchestration systems
    \item Hardware acceleration for policy enforcement
\end{itemize}

\section{Conclusion}

We presented AgentCgroup, a kernel-level resource abstraction designed specifically for interactive AI agent workloads. By aligning resource domains with agent session semantics, implementing budget-based governance with soft-pause semantics, and leveraging eBPF for programmable policy enforcement, AgentCgroup achieves significant improvements in isolation, latency, and resource efficiency.

Our work demonstrates that traditional static cgroup mechanisms are fundamentally inadequate for dynamic agent workloads, and that kernel programmability via eBPF is essential for achieving truly adaptive, reactive resource governance. AgentCgroup represents a step toward agent-oriented operating systems that understand and optimize for the unique characteristics of interactive AI agent workloads.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
